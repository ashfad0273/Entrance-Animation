<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>AnimX — Lightweight Animation Engine & Builder</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#0b1220;--panel:#141c2b;--muted:#9fb0c7;--text:#e6edf6;
    --accent:#22c55e;--accent2:#3b82f6;--border:#243047;--code:#0b1220;
  }
  *{box-sizing:border-box}
  body{margin:0; background:var(--bg); color:var(--text); font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Inter,Arial}
  .layout{display:flex; min-height:100vh}
  aside{width:340px; background:var(--panel); border-right:1px solid var(--border); padding:22px; display:flex; flex-direction:column; gap:16px}
  h1{margin:0 0 8px; font-size:18px; color:var(--muted); font-weight:700; letter-spacing:.3px}
  .group{display:grid; gap:8px}
  label{font-size:12px; color:#c7d3e5; font-weight:600}
  input,select,textarea{
    background:#101829; color:var(--text); border:1px solid var(--border);
    border-radius:8px; padding:10px 12px; font-size:14px; outline:none;
  }
  input[type="number"]{appearance:textfield}
  .row{display:grid; grid-template-columns:1fr 1fr; gap:8px}
  .actions{display:grid; gap:8px; margin-top:6px}
  button{
    background:var(--accent); color:#08111f; font-weight:800; border:0; padding:10px 12px;
    border-radius:9px; cursor:pointer; transition:transform .06s ease, opacity .2s ease
  }
  button:hover{opacity:.95} button:active{transform:translateY(1px)}
  .btn-outline{background:transparent; color:var(--text); border:1px solid var(--border)}
  .btn-blue{background:var(--accent2); color:white}
  main{flex:1; display:flex; align-items:center; justify-content:center; padding:28px}
  .preview{
    width:min(840px,100%); background:var(--panel); border:1px solid var(--border); border-radius:16px;
    padding:28px; min-height:320px; box-shadow:0 10px 30px rgba(0,0,0,.25)
  }
  .preview h2{margin:0 0 16px; color:#cfe0ff; font-size:16px; opacity:.9}
  .stage{display:flex; flex-direction:column; gap:16px}
  .stage .box{
    background:#0e1729; border:1px dashed #2b3a57; color:#cfe0ff; padding:18px; border-radius:12px;
  }
  .grid{display:grid; grid-template-columns:repeat(3,1fr); gap:10px}
  .tr-word,.tr-char{opacity:0; display:inline-block}
  /* modal */
  .modal{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.6); padding:20px; z-index:10}
  .sheet{width:min(920px,100%); background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:18px}
  .tabs{display:flex; gap:16px; border-bottom:1px solid var(--border); margin-bottom:10px}
  .tab{padding:8px 2px; cursor:pointer; color:#b7c6da; font-weight:700}
  .tab.active{color:var(--accent); border-bottom:2px solid var(--accent)}
  pre{background:var(--code); color:#d0e2ff; border:1px solid var(--border); border-radius:10px; padding:12px; overflow:auto; font-size:13px; line-height:1.5}
  .toolbar{display:flex; gap:8px; justify-content:flex-end; margin:8px 0 14px}
  .badge{display:inline-flex; gap:8px; align-items:center; font-size:12px; color:#9fb0c7}
  code.inline{background:#0e1628; border:1px solid var(--border); padding:1px 6px; border-radius:6px}
</style>
</head>
<body>
  <div class="layout">
    <aside>
      <div>
        <h1>AnimX — Builder</h1>
        <div class="group">
          <label>Animation Type</label>
          <select id="animType">
            <option>fade</option>
            <option>slide</option>
            <option>scale</option>
            <option>rotate</option>
            <option>bounce</option>
            <option>blurIn</option>
            <option>clipWipe</option>
            <option>underlineGrow</option>
            <option>shineSweep</option>
            <option>desaturateIn</option>
            <option>typewriter</option>
            <option>scramble</option>
          </select>
        </div>

        <div class="row">
          <div class="group">
            <label>Mode</label>
            <select id="unitMode">
              <option value="element">element</option>
              <option value="word" selected>word</option>
              <option value="char">char</option>
            </select>
          </div>
          <div class="group">
            <label>Direction</label>
            <select id="direction">
              <option>up</option><option>down</option><option>left</option><option>right</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div class="group">
            <label>Duration (ms)</label>
            <input id="duration" type="number" min="60" max="5000" value="600" />
          </div>
          <div class="group">
            <label>Stagger (ms)</label>
            <input id="stagger" type="number" min="0" max="1500" value="100" />
          </div>
        </div>

        <div class="row">
          <div class="group">
            <label>Easing (CSS)</label>
            <select id="ease">
              <option>ease-out</option><option>ease-in</option><option>ease-in-out</option><option>linear</option>
              <option value="cubic-bezier(0.16, 1, 0.3, 1)">springy</option>
              <option value="cubic-bezier(0.22, 1, 0.36, 1)">expo-out</option>
            </select>
          </div>
          <div class="group">
            <label>Amount (px/deg/%)*</label>
            <input id="amount" type="number" value="80" />
          </div>
        </div>

        <div class="row">
          <div class="group">
            <label>Stagger Pattern</label>
            <select id="pattern">
              <option>sequential</option>
              <option>reverse</option>
              <option>centerOut</option>
              <option>edgesIn</option>
              <option>random</option>
              <option>gridDiagonal</option>
            </select>
          </div>
          <div class="group">
            <label>Grid Columns (for gridDiagonal)</label>
            <input id="gridCols" type="number" value="3" />
          </div>
        </div>

        <div class="row">
          <div class="group">
            <label>Scroll Trigger</label>
            <select id="trigger">
              <option value="none">none</option>
              <option value="enterOnce">enterOnce</option>
              <option value="enterEvery">enterEvery</option>
            </select>
          </div>
          <div class="group">
            <label>Root Margin</label>
            <input id="rootMargin" type="text" value="0px 0px -10% 0px" />
          </div>
        </div>

        <div class="row">
          <div class="group">
            <label>Exit Animation</label>
            <select id="exitType">
              <option value="none">none</option>
              <option>fadeOut</option>
              <option>slideOut</option>
              <option>shrinkOut</option>
              <option>dissolveOut</option>
            </select>
          </div>
          <div class="group">
            <label>Exit Delay (ms)</label>
            <input id="exitDelay" type="number" value="0" />
          </div>
        </div>

        <div class="group">
          <label>Custom Text (for preview)</label>
          <textarea id="customText" rows="2">Building lightweight animation libraries is fun and fast</textarea>
        </div>

        <div class="actions">
          <button id="previewBtn" class="btn-outline">Preview</button>
          <button id="generateBtn" class="btn-blue">Generate Code</button>
        </div>
      </div>

      <div class="badge">
        <span>Engine: <code class="inline">AnimX</code> · No deps · Vanilla JS</span>
      </div>
    </aside>

    <main>
      <div class="preview">
        <h2>Preview</h2>
        <div id="stage" class="stage">
          <div class="box" id="demoText">Building lightweight animation libraries is fun and fast</div>
          <div class="grid" id="demoGrid">
            <div class="box">Card One</div>
            <div class="box">Card Two</div>
            <div class="box">Card Three</div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- Modal -->
  <div id="modal" class="modal" role="dialog" aria-modal="true">
    <div class="sheet">
      <div class="tabs">
        <div class="tab active" data-tab="js">JS</div>
        <div class="tab" data-tab="css">CSS</div>
        <div class="tab" data-tab="how">How-to</div>
      </div>

      <div class="toolbar">
        <button id="copyBtn" class="btn-outline">Copy</button>
        <button id="closeBtn" class="btn-outline">Close</button>
      </div>

      <pre id="content"></pre>
    </div>
  </div>

<script>
/* =========================
   AnimX — Lightweight Engine
   ========================= */
const AnimX = (() => {
  const split = {
    element: (el) => [el],
    word: (el) => {
      const words = el.textContent.trim().split(/\s+/);
      el.innerHTML = words.map(w => `<span class="tr-word">${w}</span>`).join(' ');
      return [...el.querySelectorAll('.tr-word')];
    },
    char: (el) => {
      const chars = el.textContent.replace(/\s+/g,' ').split('');
      el.innerHTML = chars.map(c => c === ' ' ? ' ' : `<span class="tr-char">${c}</span>`).join('');
      return [...el.querySelectorAll('.tr-char')];
    }
  };

  const orderers = {
    sequential: (arr) => arr.map((_,i)=>i),
    reverse: (arr) => arr.map((_,i)=>arr.length-1-i),
    centerOut: (arr) => {
      const n=arr.length, center=(n-1)/2;
      return arr.map((_,i)=>[Math.abs(i-center), i]).sort((a,b)=>a[0]-b[0]).map((x)=>x[1]);
    },
    edgesIn: (arr) => {
      const idx=[]; let l=0,r=arr.length-1;
      while(l<=r){ idx.push(l), l++; if(l<=r) idx.push(r), r--; }
      return idx;
    },
    random: (arr) => arr.map((_,i)=>i).sort(()=>Math.random()-0.5),
    gridDiagonal: (arr, cols=3) => {
      // assumes arr order is grid row-major
      const coords = arr.map((_,i)=>({i, r:Math.floor(i/cols), c:i%cols}));
      return coords.sort((a,b)=>(a.r+a.c)-(b.r+b.c)).map(v=>v.i);
    }
  };

  // helpers
  const setStyles = (el, styles) => { for (const k in styles) el.style[k] = styles[k]; };
  const px = (n)=> (typeof n==='number'? `${n}px` : n);

  /* ====== Animations Registry ====== */
  const registry = {
    fade: {
      prepare(el, opt){ setStyles(el,{opacity:'0', transform:'none'}); },
      play(el, opt){ setStyles(el,{transition:`opacity ${opt.duration}ms ${opt.ease}`, opacity:'1'}); }
    },
    slide: {
      prepare(el,opt){
        const m = opt.amount ?? 80;
        const map = {up:`translateY(${px(m)})`, down:`translateY(-${px(m)})`,
                     left:`translateX(${px(m)})`, right:`translateX(-${px(m)})`};
        setStyles(el,{opacity:'0', transform:map[opt.direction]||`translateY(${px(m)})`});
      },
      play(el,opt){
        setStyles(el,{transition:`transform ${opt.duration}ms ${opt.ease},opacity ${opt.duration}ms ${opt.ease}`,
                      transform:'translate(0,0)', opacity:'1'});
      }
    },
    scale: {
      prepare(el,opt){ setStyles(el,{opacity:'0', transform:'scale(0.8)'}); },
      play(el,opt){ setStyles(el,{transition:`transform ${opt.duration}ms ${opt.ease},opacity ${opt.duration}ms ${opt.ease}`,
        transform:'scale(1)', opacity:'1'}); }
    },
    rotate: {
      prepare(el,opt){ const a=opt.amount??-15; setStyles(el,{opacity:'0', transform:`rotate(${a}deg)`}); },
      play(el,opt){ setStyles(el,{transition:`transform ${opt.duration}ms ${opt.ease},opacity ${opt.duration}ms ${opt.ease}`,
        transform:'rotate(0deg)', opacity:'1'}); }
    },
    bounce: {
      prepare(el,opt){ setStyles(el,{opacity:'0', transform:'translateY(30px) scale(0.98)'}); },
      play(el,opt){
        const d = opt.duration;
        setStyles(el,{transition:`transform ${d}ms cubic-bezier(0.22,1,0.36,1),opacity ${d}ms ${opt.ease}`,
          transform:'translateY(0) scale(1)', opacity:'1'});
      }
    },
    blurIn: {
      prepare(el,opt){ setStyles(el,{opacity:'0', filter:'blur(6px)', transform:'translateY(10px)'}); },
      play(el,opt){
        setStyles(el,{transition:`filter ${opt.duration}ms ${opt.ease},opacity ${opt.duration}ms ${opt.ease},transform ${opt.duration}ms ${opt.ease}`,
          filter:'blur(0)', opacity:'1', transform:'translateY(0)'});
      }
    },
    clipWipe: {
      prepare(el,opt){
        const axis = (opt.direction==='left' || opt.direction==='right')?'X':'Y';
        const start = (opt.direction==='left' || opt.direction==='up')? '0%':'100%';
        setStyles(el,{opacity:'1', overflow:'hidden', position:'relative'});
        el.__clipWrap = document.createElement('span');
        el.__clipWrap.style.display='inline-block';
        el.__clipWrap.style.clipPath = axis==='X' ? `inset(0 100% 0 0)` : `inset(100% 0 0 0)`;
        el.__clipWrap.append(...el.childNodes);
        el.appendChild(el.__clipWrap);
      },
      play(el,opt){
        const axis = (opt.direction==='left' || opt.direction==='right')?'X':'Y';
        el.__clipWrap.style.transition = `clip-path ${opt.duration}ms ${opt.ease}`;
        el.__clipWrap.style.clipPath = axis==='X' ? `inset(0 0 0 0)` : `inset(0 0 0 0)`;
      }
    },
    underlineGrow: {
      prepare(el,opt){
        setStyles(el,{position:'relative', opacity:'1'});
        const u=document.createElement('span');
        u.style.position='absolute'; u.style.left='0'; u.style.right='0'; u.style.bottom='-2px';
        u.style.height='2px'; u.style.background='currentColor'; u.style.transform='scaleX(0)';
        u.style.transformOrigin='left'; u.style.opacity='0.9'; u.className='__underline';
        el.appendChild(u);
      },
      play(el,opt){
        const u=el.querySelector('.__underline');
        if(!u) return;
        u.style.transition=`transform ${opt.duration}ms ${opt.ease}`; u.style.transform='scaleX(1)';
      }
    },
    shineSweep: {
      prepare(el,opt){
        setStyles(el,{position:'relative', overflow:'hidden'});
        const g=document.createElement('span');
        g.className='__shine';
        Object.assign(g.style,{
          position:'absolute', top:0, bottom:0, width:'80px',
          background:'linear-gradient(120deg, transparent, rgba(255,255,255,.35), transparent)',
          transform:'translateX(-120%)', filter:'blur(0.5px)'
        });
        el.appendChild(g);
      },
      play(el,opt){
        const g=el.querySelector('.__shine'); if(!g) return;
        g.style.transition=`transform ${opt.duration}ms ${opt.ease}`;
        g.style.transform='translateX(180%)';
      }
    },
    desaturateIn: {
      prepare(el,opt){ setStyles(el,{filter:'saturate(0) contrast(0.8) brightness(1.1)', opacity:'0.7'}); },
      play(el,opt){ setStyles(el,{transition:`filter ${opt.duration}ms ${opt.ease},opacity ${opt.duration}ms ${opt.ease}`,
        filter:'saturate(1) contrast(1) brightness(1)', opacity:'1'}); }
    },
    typewriter: {
      prepare(el,opt){
        const text = el.textContent; el.textContent=''; el.__twText=text; setStyles(el,{opacity:'1', whiteSpace:'pre-wrap'});
        el.__cursor = document.createElement('span'); el.__cursor.textContent='▍';
        el.__cursor.style.marginLeft='2px'; el.__cursor.style.opacity='.6';
        el.appendChild(el.__cursor);
      },
      async play(el,opt){
        const t = el.__twText||''; const cps = Math.max(1, Math.floor((t.length)/(opt.duration/16)));
        let i=0; el.__cursor.before(document.createTextNode(''));
        const writeNode = el.childNodes[0];
        const tick=()=>new Promise(r=>requestAnimationFrame(r));
        while(i<t.length){
          writeNode.textContent += t[i++]; await tick();
          if(opt.stagger>0) await new Promise(r=>setTimeout(r, Math.max(0,opt.stagger/4)));
        }
        el.__cursor.remove();
      }
    },
    scramble: {
      prepare(el,opt){
        el.__final = el.textContent; el.textContent=''; el.__pool="ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@$%#";
        const spans = el.__final.split('').map(ch=>{
          const s=document.createElement('span'); s.textContent = ch===' ' ? ' ' : '';
          s.dataset.final = ch; s.style.display='inline-block'; s.style.minWidth='0.5ch'; return s;
        });
        spans.forEach(s=>el.appendChild(s));
        el.__spans = spans;
      },
      async play(el,opt){
        const d=opt.duration; const steps=Math.max(8, Math.floor(d/50));
        for(let k=0;k<steps;k++){
          el.__spans.forEach(s=>{
            if(s.dataset.final===' ') return;
            if(Math.random() < (k/steps)) s.textContent = s.dataset.final;
            else s.textContent = el.__pool[Math.floor(Math.random()*el.__pool.length)];
          });
          await new Promise(r=>setTimeout(r, Math.max(16, d/steps)));
        }
        el.__spans.forEach(s=> s.textContent = s.dataset.final);
      }
    },
    /* Exit animations */
    fadeOut: {
      play(el,opt){ setStyles(el,{transition:`opacity ${opt.duration}ms ${opt.ease}`, opacity:'0'}); }
    },
    slideOut: {
      play(el,opt){
        const m = opt.amount ?? 80;
        const map = {up:`translateY(-${px(m)})`, down:`translateY(${px(m)})`,
          left:`translateX(-${px(m)})`, right:`translateX(${px(m)})`};
        setStyles(el,{transition:`transform ${opt.duration}ms ${opt.ease},opacity ${opt.duration}ms ${opt.ease}`,
          transform:map[opt.direction]||`translateY(${px(m)})`, opacity:'0'});
      }
    },
    shrinkOut: {
      play(el,opt){ setStyles(el,{transition:`transform ${opt.duration}ms ${opt.ease},opacity ${opt.duration}ms ${opt.ease}`,
        transform:'scale(0.8)', opacity:'0'}); }
    },
    dissolveOut: {
      play(el,opt){ setStyles(el,{transition:`filter ${opt.duration}ms ${opt.ease},opacity ${opt.duration}ms ${opt.ease}`,
        filter:'blur(8px)', opacity:'0'}); }
    }
  };

  function animateElements(elements, type, opt){
    const anim = registry[type]; if(!anim) return;
    const order = (orderers[opt.pattern]||orderers.sequential)(elements, opt.gridCols);
    order.forEach((idx, seq)=>{
      const el = elements[idx];
      anim.prepare && anim.prepare(el, opt);
      const start = () => anim.play && anim.play(el, opt);
      const delay = seq * (opt.stagger||0);
      setTimeout(start, delay);
    });
  }

  // public API
  function run(selector, cfg={}){
    const el = typeof selector==='string' ? document.querySelector(selector) : selector;
    if(!el) return;
    const defaults = {
      type: 'fade', mode: 'word', direction:'up', duration:600, stagger:100, ease:'ease-out', amount:80,
      pattern:'sequential', gridCols:3,
      trigger:'none', rootMargin:'0px 0px -10% 0px',
      exit:{ type:'none', delay:0 }
    };
    const opt = Object.assign({}, defaults, cfg);
    const units = (split[opt.mode]||split.element)(el);

    const doEnter = () => animateElements(units, opt.type, opt);
    const doExit = () => {
      if(!opt.exit || opt.exit.type==='none') return;
      setTimeout(()=> animateElements(units, opt.exit.type, opt), opt.exit.delay||0);
    };

    if(opt.trigger==='none'){ doEnter(); return { enter:doEnter, exit:doExit }; }

    const once = opt.trigger==='enterOnce';
    const io = new IntersectionObserver((entries, obs)=>{
      entries.forEach(entry=>{
        if(entry.isIntersecting){
          doEnter();
          if(once) obs.unobserve(entry.target);
        } else if(!once){
          // optional: re-run exit when leaving
          doExit();
        }
      });
    }, {root:null, rootMargin:opt.rootMargin, threshold:0.1});
    io.observe(el);
    return { enter:doEnter, exit:doExit, observer:io };
  }

  return { run, registry, orderers, split };
})();

/* =========================
   Builder wiring
   ========================= */
const els = {
  animType: document.getElementById('animType'),
  unitMode: document.getElementById('unitMode'),
  direction: document.getElementById('direction'),
  duration: document.getElementById('duration'),
  stagger: document.getElementById('stagger'),
  ease: document.getElementById('ease'),
  amount: document.getElementById('amount'),
  pattern: document.getElementById('pattern'),
  gridCols: document.getElementById('gridCols'),
  trigger: document.getElementById('trigger'),
  rootMargin: document.getElementById('rootMargin'),
  exitType: document.getElementById('exitType'),
  exitDelay: document.getElementById('exitDelay'),
  customText: document.getElementById('customText'),
  demoText: document.getElementById('demoText'),
  demoGrid: document.getElementById('demoGrid'),
  previewBtn: document.getElementById('previewBtn'),
  generateBtn: document.getElementById('generateBtn'),
};
const modal = {
  root: document.getElementById('modal'),
  content: document.getElementById('content'),
  copy: document.getElementById('copyBtn'),
  close: document.getElementById('closeBtn'),
  tabs: [...document.querySelectorAll('.tab')],
};
let lastInstance = null;

function getConfig(){
  return {
    type: els.animType.value,
    mode: els.unitMode.value,
    direction: els.direction.value,
    duration: +els.duration.value,
    stagger: +els.stagger.value,
    ease: els.ease.value,
    amount: +els.amount.value,
    pattern: els.pattern.value,
    gridCols: +els.gridCols.value,
    trigger: 'none',
    exit: { type: els.exitType.value, delay: +els.exitDelay.value }
  };
}

function preview(){
  // set text
  els.demoText.textContent = els.customText.value;
  // reset grid items text
  els.demoGrid.querySelectorAll('.box').forEach((b,i)=>b.textContent = ['Card One','Card Two','Card Three'][i] || `Card ${i+1}`);

  // re-run
  if(lastInstance && lastInstance.observer){ lastInstance.observer.disconnect(); }
  els.demoText.innerHTML = els.customText.value; // reset any split spans
  els.demoGrid.innerHTML = `
    <div class="box">Card One</div>
    <div class="box">Card Two</div>
    <div class="box">Card Three</div>`;

  lastInstance = AnimX.run('#demoText', getConfig());
  // also show gridDiagonal patterns
  AnimX.run('#demoGrid', { ...getConfig(), mode:'element', pattern: els.pattern.value, gridCols:+els.gridCols.value });
}

els.previewBtn.addEventListener('click', preview);
window.addEventListener('load', preview);

/* ===== Code Generator (JS/CSS/How-to) ===== */
const jsTemplate = (cfg) => `// AnimX minimal usage
// 1) include AnimX (engine) or copy the class from repo
// 2) run with your selector:
AnimX.run("#myText", {
  type: "${cfg.type}",
  mode: "${cfg.mode}",          // "element" | "word" | "char"
  direction: "${cfg.direction}",// up|down|left|right (used by slide/clip/exit)
  duration: ${cfg.duration},
  stagger: ${cfg.stagger},
  ease: "${cfg.ease}",
  amount: ${cfg.amount},        // px/deg depending on type
  pattern: "${cfg.pattern}",    // sequential|reverse|centerOut|edgesIn|random|gridDiagonal
  gridCols: ${cfg.gridCols},
  trigger: "none",              // or "enterOnce" | "enterEvery"
  rootMargin: "0px 0px -10% 0px",
  exit: { type: "${cfg.exit.type}", delay: ${cfg.exit.delay} }
});`;

const cssSnippet = `/* Minimal CSS helpers (include once) */
.tr-word,.tr-char{opacity:0;display:inline-block}`

const howTo = `Integration:
1. Copy the AnimX engine file (or this single-page build) into your project.
2. Put your text element in HTML, e.g. <h1 id="myText">Hello World</h1>.
3. Call AnimX.run("#myText", { ...options }) with a config like the JS tab.
4. For scroll-based reveal, set { trigger: "enterOnce" } and include rootMargin if needed.
5. Available types: fade, slide, scale, rotate, bounce, blurIn, clipWipe, underlineGrow, shineSweep, desaturateIn, typewriter, scramble.
6. Stagger patterns: sequential, reverse, centerOut, edgesIn, random, gridDiagonal (set gridCols accordingly).
7. Exit animations: fadeOut, slideOut, shrinkOut, dissolveOut.`;

function openModal(kind, cfg){
  modal.root.style.display='flex';
  modal.tabs.forEach(t=>t.classList.remove('active'));
  const active = modal.tabs.find(t=>t.dataset.tab===kind); active.classList.add('active');

  modal.content.textContent = (kind==='js' ? jsTemplate(cfg) : kind==='css' ? cssSnippet : howTo);
  modal.copy.onclick = () => { navigator.clipboard.writeText(modal.content.textContent); modal.copy.textContent='Copied'; setTimeout(()=>modal.copy.textContent='Copy',1100); };
}
modal.close.onclick = ()=> modal.root.style.display='none';
modal.tabs.forEach(t=> t.addEventListener('click',()=> openModal(t.dataset.tab, getConfig())));

els.generateBtn.addEventListener('click', ()=> openModal('js', getConfig()));
</script>
</body>
</html>
