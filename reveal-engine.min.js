
/*! RevealEngine v2 — single-class/single-attr, CDN-ready, ~minified
 * Usage: <div class="reveal" data-reveal="fade up 700 40 ease-out delay-200 scroll once"></div>
 * Tokens: type[fade|slide|scale|rotate|bounce|blur|clip|underline|desat|type|scramble]
 *         direction[up|down|left|right] mode[element|word|char]
 *         numbers = duration(ms) then stagger(ms) (first seen)
 *         ease-<any> | delay-<ms> | amount-<px> | stagger-<ms>
 *         exit-[fade|slide|shrink|dissolve] | exit-delay-<ms>
 *         scroll | no-scroll | once
 */
(function(){
"use strict";
const W=window,D=document;const clamp=(n,a,b)=>Math.min(b,Math.max(a,n));
const qA=(s,r=D)=>Array.from(r.querySelectorAll(s));
const set=(el,o)=>{for(const k in o)el.style[k]=o[k];};
const rm=(el,ks)=>ks.forEach(k=>el.style.removeProperty(k.replace(/[A-Z]/g,m=>"-"+m.toLowerCase())));
const tfOrigin=(dir)=>({up:"50% 0%",down:"50% 100%",left:"0% 50%",right:"100% 50%"}[dir]||"50% 50%");
const now=()=>W.performance&&performance.now?performance.now():Date.now();

const TYPES=["fade","slide","scale","rotate","bounce","blur","clip","underline","desat","type","scramble"];
const DIRS=["up","down","left","right"]; const MODES=["element","word","char"];
const EXITS={fade:1,slide:1,shrink:1,dissolve:1};

function parse(el){
  const s=(el.getAttribute("data-reveal")||"").trim();
  const tks=s.split(/\s+/);
  const cfg={type:"fade",dir:"up",mode:"element",dur:700,st:80,ease:"ease-out",amt:80,delay:0,exit:null,exitDelay:0,scroll:null,once:false};
  let seenDur=false,seenSt=false;
  for(let tk of tks){
    if(!tk)continue;
    const low=tk.toLowerCase();
    if(TYPES.includes(low)) cfg.type=low;
    else if(DIRS.includes(low)) cfg.dir=low;
    else if(MODES.includes(low)) cfg.mode=low;
    else if(low==="scroll") cfg.scroll=true;
    else if(low==="no-scroll") cfg.scroll=false;
    else if(low==="once") cfg.once=true;
    else if(/^ease/.test(low)||/^cubic-bezier/.test(low)) cfg.ease=tk;
    else if(/^delay-(\d+)/.test(low)) cfg.delay=+low.split("-")[1];
    else if(/^stagger-(\d+)/.test(low)) {cfg.st=+low.split("-")[1]; seenSt=true;}
    else if(/^amount-(\-?\d+)/.test(low)) cfg.amt=+low.split("-")[1];
    else if(/^exit-(fade|slide|shrink|dissolve)/.test(low)) cfg.exit=low.split("-")[1];
    else if(/^exit-delay-(\d+)/.test(low)) cfg.exitDelay=+low.split("-")[2];
    else if(/^\d+$/.test(low)){const n=+low; if(!seenDur){cfg.dur=n; seenDur=true;} else if(!seenSt){cfg.st=n; seenSt=true;}}
  }
  return cfg;
}

function splitText(el,mode){
  if(mode==="element") return [el];
  const state=el.__rvSplit;
  if(state && state.mode===mode) return state.nodes;
  if(state && state.mode!==mode){ // restore original before re-splitting
    el.innerHTML=state.html; el.__rvSplit=null;
  } else if(!state){ el.__rvOrigHTML=el.innerHTML; }
  const textNodes=[]; const walker=D.createTreeWalker(el,NodeFilter.SHOW_TEXT,null,false);
  while(walker.nextNode()) if(walker.currentNode.nodeValue.trim().length) textNodes.push(walker.currentNode);
  const nodes=[];
  textNodes.forEach(tn=>{
    const txt=tn.nodeValue; const frag=D.createDocumentFragment();
    if(mode==="word"){
      const parts=txt.split(/(\s+)/);
      parts.forEach(p=>{
        if(/\s+/.test(p)) frag.appendChild(D.createTextNode(p));
        else{const sp=D.createElement("span");sp.className="rv-w";sp.textContent=p; sp.style.display="inline-block"; frag.appendChild(sp); nodes.push(sp);}
      });
    }else{ // char
      for(let i=0;i<txt.length;i++){
        const ch=txt[i];
        if(ch===" "){frag.appendChild(D.createTextNode(" "));}
        else{const sp=D.createElement("span");sp.className="rv-c";sp.textContent=ch; sp.style.display="inline-block"; frag.appendChild(sp); nodes.push(sp);}
      }
    }
    tn.parentNode.replaceChild(frag,tn);
  });
  el.__rvSplit={mode,nodes,html:el.__rvOrigHTML??el.innerHTML};
  return nodes.length?nodes:[el];
}

function mapDirTransform(dir,amt,axisFallback){
  const a=typeof amt==="number"?amt:parseFloat(amt)||80;
  const map={up:`translateY(${a}px)`,down:`translateY(${-a}px)`,left:`translateX(${a}px)`,right:`translateX(${-a}px)`};
  return map[dir]||map[axisFallback||"up"];
}

const FX={
  fade:{prep:(n,c)=>set(n,{opacity:"0",willChange:"opacity"}),play:(n,c)=>set(n,{transition:`opacity ${c.dur}ms ${c.ease}`,opacity:"1"})},
  slide:{prep:(n,c)=>set(n,{opacity:"0",transform:mapDirTransform(c.dir,c.amt),willChange:"transform,opacity",transformOrigin:tfOrigin(c.dir)}),
         play:(n,c)=>set(n,{transition:`transform ${c.dur}ms ${c.ease},opacity ${c.dur}ms ${c.ease}`,transform:"translate(0,0)",opacity:"1"})},
  scale:{prep:(n,c)=>set(n,{opacity:"0",transform:"scale(.86)",willChange:"transform,opacity",transformOrigin:tfOrigin(c.dir)}),
         play:(n,c)=>set(n,{transition:`transform ${c.dur}ms ${c.ease},opacity ${c.dur}ms ${c.ease}`,transform:"scale(1)",opacity:"1"})},
  rotate:{prep:(n,c)=>set(n,{opacity:"0",transform:`rotate(${(c.amt||30)}deg)`,willChange:"transform,opacity",transformOrigin:tfOrigin(c.dir)}),
          play:(n,c)=>set(n,{transition:`transform ${c.dur}ms ${c.ease},opacity ${c.dur}ms ${c.ease}`,transform:"rotate(0deg)",opacity:"1"})},
  bounce:{prep:(n,c)=>set(n,{opacity:"0",transform:"translateY(28px) scale(.98)",willChange:"transform,opacity"}),
          play:(n,c)=>set(n,{transition:`transform ${c.dur}ms cubic-bezier(.22,1,.36,1),opacity ${c.dur}ms ${c.ease}`,transform:"translateY(0) scale(1)",opacity:"1"})},
  blur:{prep:(n,c)=>set(n,{opacity:"0",filter:"blur(8px)",transform:"translateY(8px)",willChange:"filter,opacity,transform"}),
        play:(n,c)=>set(n,{transition:`filter ${c.dur}ms ${c.ease},opacity ${c.dur}ms ${c.ease},transform ${c.dur}ms ${c.ease}`,filter:"blur(0)",opacity:"1",transform:"translateY(0)"})},
  clip:{prep:(n,c)=>{if(n.__rvClip)return; n.style.overflow="hidden"; n.style.position=n.style.position||"relative";
                     const w=D.createElement("span");w.className="rv-clip";set(w,{display:"inline-block",clipPath:(c.dir==="left"||c.dir==="right")?"inset(0 100% 0 0)":"inset(100% 0 0 0)",opacity:"0",willChange:"clip-path,opacity"});
                     while(n.firstChild) w.appendChild(n.firstChild); n.appendChild(w); n.__rvClip=w;},
        play:(n,c)=>{const w=n.__rvClip; if(!w) return; set(w,{transition:`clip-path ${c.dur}ms ${c.ease},opacity ${c.dur}ms ${c.ease}`,clipPath:"inset(0 0 0 0)",opacity:"1"});}},
  underline:{prep:(n,c)=>{if(n.querySelector(".rv-ul"))return; n.style.position=n.style.position||"relative";
                          const u=D.createElement("span");u.className="rv-ul"; set(u,{position:"absolute",left:"0",right:"0",bottom:"-2px",height:"2px",background:"currentColor",transform:"scaleX(0)",transformOrigin:"left",opacity:".9",willChange:"transform"}); n.appendChild(u);},
             play:(n,c)=>{const u=n.querySelector(".rv-ul"); if(u) set(u,{transition:`transform ${c.dur}ms ${c.ease}`,transform:"scaleX(1)"});}},
  desat:{prep:(n,c)=>set(n,{filter:"saturate(0) contrast(.95) brightness(1.05)",opacity:".75",willChange:"filter,opacity"}),
         play:(n,c)=>set(n,{transition:`filter ${c.dur}ms ${c.ease},opacity ${c.dur}ms ${c.ease}`,filter:"saturate(1) contrast(1) brightness(1)",opacity:"1"})},
  type:{prep:(n,c)=>{if(n.__rvType)return; const full=(n.textContent||""); n.textContent=""; const cur=D.createElement("span"); cur.className="rv-cur"; cur.textContent="▍"; set(cur,{opacity:".6",marginLeft:"2px",display:"inline-block"}); n.appendChild(cur); n.__rvType={full,cursor:cur};},
        play:(n,c)=>{const st=n.__rvType; if(!st)return;
          const holder=D.createTextNode(""); n.insertBefore(holder,st.cursor);
          const total=Math.max(1,c.dur); const start=now(); const step=()=>{const t=clamp((now()-start)/total,0,1); const count=Math.floor(st.full.length*t); holder.textContent=st.full.slice(0,count); if(t<1) rAF(step); else{st.cursor&&st.cursor.remove(); n.__rvType=null;}}; rAF(step);}
       },
  scramble:{prep:(n,c)=>{if(n.__rvScr)return; const final=(n.textContent||""); n.textContent=""; const pool="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@$%#";
            const spans=[]; for(let ch of final){if(ch===" "){n.appendChild(D.createTextNode(" ")); continue;} const s=D.createElement("span"); s.className="rv-sc"; s.textContent=""; set(s,{display:"inline-block",minWidth:".6em"}); s.dataset.f=ch; n.appendChild(s); spans.push(s);} n.__rvScr={spans,pool,final};},
            play:(n,c)=>{const st=n.__rvScr; if(!st)return; const total=Math.max(200,c.dur); const start=now(); const step=()=>{const t=clamp((now()-start)/total,0,1);
                st.spans.forEach(s=>{const p=t; s.textContent=(Math.random()<p)?s.dataset.f:st.pool[(Math.random()*st.pool.length)|0];});
                if(t<1) rAF(step); else {st.spans.forEach(s=>s.textContent=s.dataset.f); n.__rvScr=null;}}; rAF(step);}}
};

const EXITFX={
  fade:(n,c)=>set(n,{transition:`opacity ${c.dur}ms ${c.ease}`,opacity:"0"}),
  slide:(n,c)=>set(n,{transition:`transform ${c.dur}ms ${c.ease},opacity ${c.dur}ms ${c.ease}`,transform:mapDirTransform(c.dir,c.amt,c.dir),opacity:"0"}),
  shrink:(n,c)=>set(n,{transition:`transform ${c.dur}ms ${c.ease},opacity ${c.dur}ms ${c.ease}`,transform:"scale(.86)",opacity:"0"}),
  dissolve:(n,c)=>set(n,{transition:`filter ${c.dur}ms ${c.ease},opacity ${c.dur}ms ${c.ease}`,filter:"blur(8px)",opacity:"0"})
};

const rAF=(cb)=>requestAnimationFrame(cb);

function sequence(units,fx,cfg,baseDelay){
  const T=cfg.dur, S=cfg.st, E=cfg.ease, DLY=cfg.delay+(baseDelay||0);
  units.forEach((n,i)=>{
    fx.prep&&fx.prep(n,cfg);
  });
  const startAt=now()+DLY;
  function tick(){
    const t=now();
    units.forEach((n,i)=>{
      const fireAt=startAt+i*S;
      if(!n.__rvPlayed && t>=fireAt-1){ n.__rvPlayed=1; fx.play&&fx.play(n,cfg); }
    });
    const lastAt=startAt+(units.length-1)*S+T+16;
    if(t<lastAt) rAF(tick);
  }
  rAF(tick);
}

function resetNode(n){
  rm(n,["transition","transform","opacity","filter","clipPath","willChange","transformOrigin"]);
}

function prepElement(el,cfg){
  // Reset container-level styles (and wrappers)
  resetNode(el);
  if(el.__rvClip){ // unwrap clip
    const w=el.__rvClip; while(w.firstChild) el.appendChild(w.firstChild); w.remove(); el.__rvClip=null;
  }
  // Prepare units set
  const units=splitText(el,cfg.mode);
  units.forEach(u=>{resetNode(u); u.__rvPlayed=0;});
  return units;
}

function playOnce(el,cfg){
  const fx=FX[cfg.type]||FX.fade;
  const units=prepElement(el,cfg);
  sequence(units,fx,cfg,0);
  if(cfg.exit){
    const exitFx=EXITFX[cfg.exit];
    if(exitFx){
      const total=cfg.dur + (units.length? (units.length-1)*cfg.st : 0);
      setTimeout(()=>{units.forEach((n,i)=>{exitFx(n,cfg);}); setTimeout(()=>{units.forEach(resetNode);},cfg.dur+cfg.exitDelay+34);}, cfg.exitDelay+total);
    }
  }
}

const Engine=function(){
  this.observer=null;
  this.items=new Set();
};
Engine.config={scrollTrigger:true,rootMargin:"0px 0px -8% 0px",threshold:0.1};
Engine.prototype._observe=function(el,cfg){
  if(!this.observer){
    this.observer=new IntersectionObserver((ents)=>{
      ents.forEach(ent=>{
        const el=ent.target, cfg=el.__rvCfg;
        if(!cfg) return;
        if(ent.isIntersecting){
          if(el.__rvLock) return;
          el.__rvLock=1; playOnce(el,cfg);
          if(cfg.once){ this.observer.unobserve(el); }
          else{ // allow retrigger when leaving & re-entering
            setTimeout(()=>{el.__rvLock=0;}, cfg.dur + 50);
          }
        }
      });
    },{root:null,rootMargin:Engine.config.rootMargin,threshold:Engine.config.threshold});
  }
  this.observer.observe(el);
};
Engine.prototype.init=function(root){
  const els=qA(".reveal",root||D);
  els.forEach(el=>{
    const cfg=parse(el);
    if(cfg.scroll===null) cfg.scroll=!!Engine.config.scrollTrigger;
    el.__rvCfg=cfg; this.items.add(el);
    if(cfg.scroll) this._observe(el,cfg);
    else setTimeout(()=>playOnce(el,cfg),Math.max(0,cfg.delay||0));
  });
};
Engine.prototype.play=function(el){
  if(!el) return; const cfg=el.__rvCfg||parse(el); el.__rvCfg=cfg; playOnce(el,cfg);
};
Engine.prototype.refresh=function(root){
  const els=qA(".reveal",root||D);
  els.forEach(el=>{
    const oldCfg=el.__rvCfg; const cfg=parse(el); el.__rvCfg=cfg;
    if(this.observer) try{this.observer.unobserve(el);}catch(e){}
    if(cfg.scroll===null) cfg.scroll=!!Engine.config.scrollTrigger;
    if(cfg.scroll) this._observe(el,cfg);
  });
};

const engine=new Engine();
W.RevealEngine=engine; RevealEngine.config=Engine.config;

// Auto-init on DOM ready
if(D.readyState==="loading"){D.addEventListener("DOMContentLoaded",()=>engine.init());}
else{engine.init();}
})();

