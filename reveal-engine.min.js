/* ==========================================================
Reveal Engine (vanilla JS) — class-based auto-init
Prefix: reveal-
Types: fade | slide | scale | rotate | bounce | blur | clip | underline | shine | desat | type | scramble
Modes: element | reveal-word | reveal-char
Direction: reveal-up | reveal-down | reveal-left | reveal-right
Data overrides: data-reveal-duration, data-reveal-stagger, data-reveal-ease, data-reveal-amount, data-reveal-exit, data-reveal-exit-delay
========================================================== */

(function () {
  const qAll = (s, r = document) => Array.from(r.querySelectorAll(s));
  const set = (el, st) => { for (const k in st) el.style[k] = st[k]; };
  const px = n => typeof n === "number" ? `${n}px` : n;
  const has = (el, c) => el.classList.contains(c);

  const splitters = {
    element: el => [el],
    word: el => {
      const words = el.textContent.trim().split(/\s+/);
      el.innerHTML = words.map(w => `<span class="reveal-word">${w}</span>`).join(' ');
      return qAll('.reveal-word', el);
    },
    char: el => {
      const chars = el.textContent.replace(/\s+/g, ' ').split('');
      el.innerHTML = chars.map(c => c === ' ' ? ' ' : `<span class="reveal-char">${c}</span>`).join('');
      return qAll('.reveal-char', el);
    }
  };

  const orderers = {
    sequential: a => a.map((_, i) => i),
    random: a => a.map((_, i) => i).sort(() => Math.random() - 0.5),
    centerOut: a => {
      const n = a.length, c = (n - 1) / 2;
      return a.map((_, i) => [Math.abs(i - c), i]).sort((x, y) => x[0] - y[0]).map(x => x[1]);
    }
  };

  function readConfig(el) {
    const type = [
      "fade", "slide", "scale", "rotate", "bounce", "blur", "clip",
      "underline", "shine", "desat", "type", "scramble"
    ].find(t => has(el, `reveal-${t}`)) || "fade";

    const mode = has(el, "reveal-char") ? "char" :
                 has(el, "reveal-word") ? "word" : "element";
    const direction = has(el, "reveal-down") ? "down" :
                      has(el, "reveal-left") ? "left" :
                      has(el, "reveal-right") ? "right" : "up";
    const pattern = has(el, "reveal-center") ? "centerOut" :
                    has(el, "reveal-random") ? "random" : "sequential";

    const num = (k, d) => {
      const v = el.getAttribute(k);
      return v == null || v === "" || isNaN(+v) ? d : +v;
    };
    const str = (k, d) => el.getAttribute(k) ?? d;

    return {
      type, mode, direction, pattern,
      duration: num("data-reveal-duration", 700),
      stagger: num("data-reveal-stagger", 90),
      ease: str("data-reveal-ease", "ease-out"),
      amount: num("data-reveal-amount", 80),
      exit: str("data-reveal-exit", "none"),
      exitDelay: num("data-reveal-exit-delay", 0)
    };
  }

  const FX = {
    fade: {
      prep: el => set(el, { opacity: "0" }),
      play: (el, c) => set(el, { transition: `opacity ${c.duration}ms ${c.ease}`, opacity: "1" })
    },
    slide: {
      prep: (el, c) => {
        const m = c.amount;
        const map = { up: `translateY(${px(m)})`, down: `translateY(-${px(m)})`, left: `translateX(${px(m)})`, right: `translateX(-${px(m)})` };
        set(el, { opacity: "0", transform: map[c.direction] || map.up });
      },
      play: (el, c) => set(el, {
        transition: `transform ${c.duration}ms ${c.ease},opacity ${c.duration}ms ${c.ease}`,
        transform: "translate(0,0)", opacity: "1"
      })
    },
    scale: {
      prep: el => set(el, { opacity: "0", transform: "scale(0.85)" }),
      play: (el, c) => set(el, {
        transition: `transform ${c.duration}ms ${c.ease},opacity ${c.duration}ms ${c.ease}`,
        transform: "scale(1)", opacity: "1"
      })
    },
    rotate: {
      prep: (el, c) => set(el, { opacity: "0", transform: `rotate(${px(c.amount)}deg)` }),
      play: (el, c) => set(el, {
        transition: `transform ${c.duration}ms ${c.ease},opacity ${c.duration}ms ${c.ease}`,
        transform: "rotate(0)", opacity: "1"
      })
    },
    bounce: {
      prep: el => set(el, { opacity: "0", transform: "translateY(28px) scale(0.98)" }),
      play: (el, c) => set(el, {
        transition: `transform ${c.duration}ms cubic-bezier(0.22,1,0.36,1),opacity ${c.duration}ms ${c.ease}`,
        transform: "translateY(0) scale(1)", opacity: "1"
      })
    },
    blur: {
      prep: el => set(el, { opacity: "0", filter: "blur(6px)", transform: "translateY(8px)" }),
      play: (el, c) => set(el, {
        transition: `filter ${c.duration}ms ${c.ease},opacity ${c.duration}ms ${c.ease},transform ${c.duration}ms ${c.ease}`,
        filter: "blur(0)", opacity: "1", transform: "translateY(0)"
      })
    },
    clip: {
      prep: (el, c) => {
        if (el.__clip) return; // prevent duplicate wrapping
        el.style.overflow = "hidden";
        el.style.position = "relative";
        const axis = (c.direction === "left" || c.direction === "right") ? "X" : "Y";
        const wrap = document.createElement("span");
        wrap.style.display = "inline-block";
        wrap.style.clipPath = axis === "X" ? "inset(0 100% 0 0)" : "inset(100% 0 0 0)";
        wrap.style.opacity = "0";
        wrap.append(...Array.from(el.childNodes));
        el.appendChild(wrap);
        el.__clip = wrap;
      },
      play: (el, c) => {
        const w = el.__clip;
        if (!w) return;
        w.style.transition = `clip-path ${c.duration}ms ${c.ease},opacity ${c.duration}ms ${c.ease}`;
        w.style.clipPath = "inset(0 0 0 0)";
        w.style.opacity = "1";
      }
    },
    underline: {
      prep: el => {
        if (el.querySelector(".__underline")) return;
        el.style.position = "relative";
        const u = document.createElement("span");
        Object.assign(u.style, {
          position: "absolute", left: 0, right: 0, bottom: "-2px",
          height: "2px", background: "currentColor",
          transform: "scaleX(0)", transformOrigin: "left", opacity: ".9"
        });
        u.className = "__underline";
        el.appendChild(u);
      },
      play: (el, c) => {
        const u = el.querySelector(".__underline");
        if (u) {
          u.style.transition = `transform ${c.duration}ms ${c.ease}`;
          u.style.transform = "scaleX(1)";
        }
      }
    },
    shine: {
      prep: el => {
        if (el.querySelector(".__shine")) return;
        el.style.position = "relative";
        el.style.overflow = "hidden";
        const g = document.createElement("span");
        Object.assign(g.style, {
          position: "absolute", top: 0, bottom: 0, width: "80px",
          background: "linear-gradient(120deg,transparent,rgba(255,255,255,.35),transparent)",
          transform: "translateX(-120%)"
        });
        g.className = "__shine";
        el.appendChild(g);
      },
      play: (el, c) => {
        const g = el.querySelector(".__shine");
        if (g) {
          g.style.transition = `transform ${c.duration}ms ${c.ease}`;
          g.style.transform = "translateX(180%)";
        }
      }
    },
    desat: {
      prep: el => set(el, { filter: "saturate(0) contrast(0.9) brightness(1.05)", opacity: ".7" }),
      play: (el, c) => set(el, {
        transition: `filter ${c.duration}ms ${c.ease},opacity ${c.duration}ms ${c.ease}`,
        filter: "saturate(1) contrast(1) brightness(1)", opacity: "1"
      })
    },
    type: {
      prep: el => {
        const t = el.textContent;
        el.textContent = "";
        el.__tw = t;
        const cur = document.createElement("span");
        cur.textContent = "▍";
        cur.className = "reveal-cursor";
        cur.style.verticalAlign = "baseline";
        el.appendChild(cur);
      },
      play: async (el, c) => {
        const t = el.__tw || "";
        const holder = document.createTextNode("");
        el.firstChild.before(holder);
        const tick = () => new Promise(r => requestAnimationFrame(r));
        for (let i = 0; i < t.length; i++) {
          holder.textContent += t[i];
          await tick();
          if (c.stagger > 0) await new Promise(r => setTimeout(r, Math.max(0, c.stagger / 4)));
        }
        const cur = el.querySelector(".reveal-cursor");
        cur && cur.remove();
      }
    },
    scramble: {
      prep: el => {
        const fin = el.textContent;
        el.textContent = "";
        const pool = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@$%#";
        const spans = fin.split("").map(ch => {
          const s = document.createElement("span");
          s.textContent = ch === " " ? " " : "";
          s.dataset.final = ch;
          s.style.display = "inline-block";
          s.style.minWidth = ch === " " ? "0" : "0.6em";
          return s;
        });
        spans.forEach(s => el.appendChild(s));
        el.__scr = spans;
        el.__pool = pool;
      },
      play: async (el, c) => {
        const d = c.duration, steps = Math.max(8, Math.floor(d / 50));
        for (let k = 0; k < steps; k++) {
          el.__scr.forEach(s => {
            if (s.dataset.final === " ") return;
            s.textContent = Math.random() < (k / steps)
              ? s.dataset.final
              : el.__pool[Math.floor(Math.random() * el.__pool.length)];
          });
          await new Promise(r => setTimeout(r, Math.max(16, d / steps)));
        }
        el.__scr.forEach(s => s.textContent = s.dataset.final);
      }
    }
  };

  const EXITS = {
    none: { play() {} },
    fadeOut: { play: (el, c) => set(el, { transition: `opacity ${c.duration}ms ${c.ease}`, opacity: "0" }) },
    slideOut: {
      play: (el, c) => {
        const m = c.amount;
        const map = { up: `translateY(-${px(m)})`, down: `translateY(${px(m)})`, left: `translateX(-${px(m)})`, right: `translateX(${px(m)})` };
        set(el, {
          transition: `transform ${c.duration}ms ${c.ease},opacity ${c.duration}ms ${c.ease}`,
          transform: map[c.direction] || map.up, opacity: "0"
        });
      }
    },
    shrinkOut: {
      play: (el, c) => set(el, {
        transition: `transform ${c.duration}ms ${c.ease},opacity ${c.duration}ms ${c.ease}`,
        transform: "scale(0.85)", opacity: "0"
      })
    },
    dissolveOut: {
      play: (el, c) => set(el, {
        transition: `filter ${c.duration}ms ${c.ease},opacity ${c.duration}ms ${c.ease}`,
        filter: "blur(8px)", opacity: "0"
      })
    }
  };

  function animateUnits(units, fx, cfg, orderer) {
    const order = (orderer || ((a) => a.map((_, i) => i)))(units);
    order.forEach((idx, seq) => {
      const el = units[idx];
      fx.prep && fx.prep(el, cfg);
      setTimeout(() => fx.play && fx.play(el, cfg), seq * (cfg.stagger || 0));
    });
  }

  function runElement(el) {
    if (el.__revealed) return; // prevent double init
    el.__revealed = true;
    const cfg = readConfig(el);
    const fx = FX[cfg.type] || FX.fade;
    const ord = orderers[cfg.pattern] || orderers.sequential;
    const units = (cfg.mode === "char"
      ? splitters.char
      : cfg.mode === "word"
      ? splitters.word
      : splitters.element)(el);

    // reset previous styles
    set(el, { opacity: "", transform: "", filter: "" });

    animateUnits(units, fx, cfg, ord);

    if (cfg.exit !== "none") {
      setTimeout(() =>
        animateUnits(units, EXITS[cfg.exit] || EXITS.none, cfg, ord),
        Math.max(0, cfg.exitDelay || 0) + cfg.duration + units.length * cfg.stagger
      );
    }
  }

  function autoInit() {
    const types = [
      "reveal-fade", "reveal-slide", "reveal-scale", "reveal-rotate",
      "reveal-bounce", "reveal-blur", "reveal-clip", "reveal-underline",
      "reveal-shine", "reveal-desat", "reveal-type", "reveal-scramble"
    ];
    const selector = types.map(c => "." + c).join(",");
    qAll(selector).forEach(runElement);
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", autoInit);
  } else {
    autoInit();
  }

  window.RevealInit = autoInit;
})();
